import React, { useState, useEffect, createContext, useContext } from 'react';
import Cookies from 'js-cookie';
import {
	NONCE_ENDPOINT,
	VERIFICATION_ENDPOINT,
	AUTH_TIMEOUT,
} from '../config/constants';

// auth flow:
// 1. verify and get http-only cookie
// 2. on good verification response, drop client side cookie with same expiration + verified address
// 3. use client-side cookie to track auth status within the site

interface AuthContextProps {
	isAuthenticated: boolean;
	login: Function;
}

interface AuthProviderProps {
	children?: React.ReactNode;
}

const AuthContext = createContext<AuthContextProps>({} as AuthContextProps);
export const useAuthContext = () => useContext(AuthContext);

const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
	const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);

	const updateAuthState = () => {
		const authCookie = Cookies.get('signer');

		if (authCookie && isAuthenticated) return;

		// remove auth if cookie is invalid
		if (!authCookie && isAuthenticated) {
			setIsAuthenticated(false);
			return;
		}

		// give auth if cookie present
		if (authCookie && !isAuthenticated) {
			setIsAuthenticated(true);
		}
	};

	// Check auth state via client-side cookie every render
	useEffect(() => {
		updateAuthState();
	}, []);

	// TODO: type arg as ethers.js signer
	const login = async (signer: any) => {
		try {
			const signerAddress = await signer.getAddress();

			// Fetch user nonce from DB (if no DB record exists for user, one will be generated by backend)
			const nonceResult = await fetch(NONCE_ENDPOINT, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({ address: signerAddress }),
			}).then(res => res.json());

			// Sign fetched nonce with connected address
			const signature = await signer.signMessage(nonceResult.nonce.toString());

			// Send signature to server for verification
			const authResult = await fetch(VERIFICATION_ENDPOINT, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({ address: signerAddress, signature }),
			}).then(res => res.json());

			// If auth successful, drop an address tracking cookie on client with an expiry one minute before the http-only token cookie
			if (authResult.ok) {
				const expires = new Date(new Date().getTime() + (AUTH_TIMEOUT - 60) * 1000);
				Cookies.set('signer', signerAddress, { expires });
				updateAuthState();
			} else {
				alert('Login attempt unsuccessful...');
			}
		} catch (error: any) {
			// If user rejects connect request, just return silently
			if (error.code === 4001) return;

			console.error(error);
			alert('Error authenicating - check console for error details...');
		}
	};

	return (
		<AuthContext.Provider value={{ isAuthenticated, login }}>
			{children}
		</AuthContext.Provider>
	);
};

export default AuthProvider;
